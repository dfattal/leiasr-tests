<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LeiaSR SDK: WeaverTracker API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="extrastyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="sr-logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LeiaSR SDK<span id="projectnumber">&#160;3e4093ae v1.34.8.37806 2025-10-23T12:33:42Z</span>
   </div>
   <div id="projectbrief">Stable</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">WeaverTracker API </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_C__GitLabRunner_builds_fe33718a_0_simulatedreality_simulatedreality_modules_srFacetrackers_documentation_public_weavertracker_api"></a> The WeaverTracker API provides similar data to the EyeTracker in that it tracks the position of the user. The big difference is that there is only one landmark position being communicated. This <code><a class="el" href="structSR__weaverPosition.html" title="C-compatible struct containing the weaver position.">SR_weaverPosition</a></code> represents the point between the user's eyes and is used internally to seperate the left from the right image presented to the user.</p>
<p >As a developer you will rarely have to use this interface directly.</p>
<h1><a class="anchor" id="autotoc_md56"></a>
Classes</h1>
<p >The WeaverTracker interface is an important piece of the <a class="el" href="namespaceSR.html" title="Namespace containing all C++ Simulated Reality classes.">SR</a> puzzle.</p>
<ul>
<li><code>SRContext</code> is an essential element of any <a class="el" href="namespaceSR.html" title="Namespace containing all C++ Simulated Reality classes.">SR</a> application, it maintains a list of all <a class="el" href="namespaceSR.html" title="Namespace containing all C++ Simulated Reality classes.">SR</a> components that are in use and cleans them up when the application ends. It also allows different components of the application to share the same Sense implementations.</li>
<li><code>Sense</code> is an interface used by the <code>SRContext</code> to keep track of any input or output devices.</li>
<li><code>WeaverTracker</code> is an interface providing access to weavertracker data.</li>
<li><code>WeaverPositionStream</code> connects <code>WeaverTracker</code> implementations with user defined <code>WeaverPositionListener</code> implementations.</li>
<li><code>WeaverPositionListener</code> is an interface to be implemented by any components of the user's application that want to receive weavertracker data.</li>
<li><code><a class="el" href="structSR__weaverPosition.html" title="C-compatible struct containing the weaver position.">SR_weaverPosition</a></code> defines the actual weavertracker data.</li>
</ul>
<h2><a class="anchor" id="autotoc_md57"></a>
WeaverTracker Data</h2>
<p >The <code><a class="el" href="structSR__weaverPosition.html" title="C-compatible struct containing the weaver position.">SR_weaverPosition</a></code> is at the center of the <code>WeaverTracker</code> interface, this is what applications can subscribe to.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    uint64_t frameId;          </div>
<div class="line">    uint64_t time;             </div>
<div class="line">    <a class="code hl_union" href="unionSR__vector3d.html">SR_point3d</a> weaverPosition; </div>
<div class="line">} <a class="code hl_struct" href="structSR__weaverPosition.html">SR_weaverPosition</a>;</div>
<div class="ttc" id="astructSR__weaverPosition_html"><div class="ttname"><a href="structSR__weaverPosition.html">SR_weaverPosition</a></div><div class="ttdoc">C-compatible struct containing the weaver position.</div><div class="ttdef"><b>Definition:</b> weaverposition.h:15</div></div>
<div class="ttc" id="aunionSR__vector3d_html"><div class="ttname"><a href="unionSR__vector3d.html">SR_vector3d</a></div><div class="ttdoc">C-compatible 3d double vector representation.</div><div class="ttdef"><b>Definition:</b> types.h:73</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md58"></a>
WeaverTracker usage</h1>
<p >Direct use of the WeaverTracker interface might not be required in your application but is very similar to use of the EyeTracker interface.</p>
<p >A specific listener object is defined, a WeaverTracker is created and attached to the listener as follows. </p><div class="fragment"><div class="line"><span class="keyword">class </span>WeaverPositionListenerImplementation : <span class="keyword">public</span> <a class="code hl_class" href="classSR_1_1WeaverPositionListener.html">SR::WeaverPositionListener</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Ensures WeaverPositionStream is cleaned up when Listener object is out of scope</span></div>
<div class="line">    <a class="code hl_class" href="classSR_1_1InputStream.html">SR::InputStream&lt;SR::WeaverPositionStream&gt;</a> stream;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The accept function can process the weaver position data as soon as it becomes available</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code hl_function" href="classSR_1_1WeaverPositionListener.html#af4fef962fc5dbdad3df08d9081bbf2c6">accept</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structSR__weaverPosition.html">SR_weaverPosition</a>&amp; frame)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Use WeaverTracker data</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Create WeaverTracker</span></div>
<div class="line">    <a class="code hl_class" href="classSR_1_1SRContext.html">SR::SRContext</a> context;</div>
<div class="line">    <a class="code hl_class" href="classSR_1_1WeaverTracker.html">SR::WeaverTracker</a>* weaverTracker = <a class="code hl_function" href="classSR_1_1WeaverTracker.html#a0af41ca454267a315b3558e7436952a1">SR::WeaverTracker::create</a>(context);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Construct listener</span></div>
<div class="line">    WeaverPositionListenerImplementation listener;</div>
<div class="line">    listener.stream.set(weaverTracker-&gt;<a class="code hl_function" href="classSR_1_1WeaverTracker.html#a5dccda70532b79b21f20b17e68ca90a1">openWeaverPositionStream</a>(&amp;listener));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Start tracking</span></div>
<div class="line">    context.<a class="code hl_function" href="classSR_1_1SRContext.html#a6e889901b983ced27c24732fcae177c1">initialize</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Ensure that the program does not exit immediately.</span></div>
<div class="line">    <span class="keywordtype">char</span> inchar;</div>
<div class="line">    std::cin &gt;&gt; inchar; <span class="comment">//wait for key press</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassSR_1_1InputStream_html"><div class="ttname"><a href="classSR_1_1InputStream.html">SR::InputStream</a></div><div class="ttdoc">Template class to wrap data stream to a listener object.</div><div class="ttdef"><b>Definition:</b> inputstream.h:20</div></div>
<div class="ttc" id="aclassSR_1_1SRContext_html"><div class="ttname"><a href="classSR_1_1SRContext.html">SR::SRContext</a></div><div class="ttdoc">Maintains WorldObject and Sense objects during the application lifetime.</div><div class="ttdef"><b>Definition:</b> srcontext.h:75</div></div>
<div class="ttc" id="aclassSR_1_1SRContext_html_a6e889901b983ced27c24732fcae177c1"><div class="ttname"><a href="classSR_1_1SRContext.html#a6e889901b983ced27c24732fcae177c1">SR::SRContext::initialize</a></div><div class="ttdeci">void initialize()</div><div class="ttdoc">Initialize all senses.</div></div>
<div class="ttc" id="aclassSR_1_1WeaverPositionListener_html"><div class="ttname"><a href="classSR_1_1WeaverPositionListener.html">SR::WeaverPositionListener</a></div><div class="ttdoc">Interface for listening to SR_weaverPosition updates.</div><div class="ttdef"><b>Definition:</b> weaverpositionlistener.h:15</div></div>
<div class="ttc" id="aclassSR_1_1WeaverPositionListener_html_af4fef962fc5dbdad3df08d9081bbf2c6"><div class="ttname"><a href="classSR_1_1WeaverPositionListener.html#af4fef962fc5dbdad3df08d9081bbf2c6">SR::WeaverPositionListener::accept</a></div><div class="ttdeci">virtual void accept(const SR_weaverPosition &amp;frame)=0</div><div class="ttdoc">Accept an SR_weaverPosition frame.</div></div>
<div class="ttc" id="aclassSR_1_1WeaverTracker_html"><div class="ttname"><a href="classSR_1_1WeaverTracker.html">SR::WeaverTracker</a></div><div class="ttdoc">Sense class which provides weave tracking functionality to the SR system.</div><div class="ttdef"><b>Definition:</b> weavertracker.h:35</div></div>
<div class="ttc" id="aclassSR_1_1WeaverTracker_html_a0af41ca454267a315b3558e7436952a1"><div class="ttname"><a href="classSR_1_1WeaverTracker.html#a0af41ca454267a315b3558e7436952a1">SR::WeaverTracker::create</a></div><div class="ttdeci">static WeaverTracker * create(SRContext &amp;context)</div><div class="ttdoc">Creates a functional WeaverTracker instance.</div></div>
<div class="ttc" id="aclassSR_1_1WeaverTracker_html_a5dccda70532b79b21f20b17e68ca90a1"><div class="ttname"><a href="classSR_1_1WeaverTracker.html#a5dccda70532b79b21f20b17e68ca90a1">SR::WeaverTracker::openWeaverPositionStream</a></div><div class="ttdeci">virtual std::shared_ptr&lt; WeaverPositionStream &gt; openWeaverPositionStream(WeaverPositionListener *listener)=0</div><div class="ttdoc">Creates a WeaverPositionStream for listener to be connected to.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md59"></a>
Prediction</h1>
<p >To ensure that your application is as responsive as possible a specific <code>WeaverTracker</code> implementation can be constructed. (this is done by default in the available weaver classes for OpenGL and DirectX) The following is a short description of relevant classes.</p>
<ul>
<li><code>PredictingWeaverTracker</code> is an implementation of the <code>WeaverTracker</code> interface that offers more control over the filtering of the output values to the application developer.</li>
<li><code>WeaverPositionPredictor</code> is an implementation of the <code>PredictiveFilter&lt;<a class="el" href="structSR__weaverPosition.html" title="C-compatible struct containing the weaver position.">SR_weaverPosition</a>, uint64_t&gt;</code> interface that defines how <code><a class="el" href="structSR__weaverPosition.html" title="C-compatible struct containing the weaver position.">SR_weaverPosition</a></code> data is filtered to provide accurate predictions.</li>
</ul>
<h1><a class="anchor" id="autotoc_md60"></a>
PredictingWeaverTracker usage</h1>
<p >The <code>PredictingWeaverTracker::create</code> function can be used in exactly the same way as the <code>WeaverTracker::create</code> function but the <code>PredictingWeaverTracker</code> will only provide output to connected <code>WeaverPositionListener</code> instances when one of the <code>predict</code> functions is called.</p>
<p >An application might define the same type of <code>EyePairListener</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>WeaverPositionListenerImplementation : <span class="keyword">public</span> <a class="code hl_class" href="classSR_1_1WeaverPositionListener.html">SR::WeaverPositionListener</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Ensures WeaverPositionStream is cleaned up when Listener object is out of scope</span></div>
<div class="line">    <a class="code hl_class" href="classSR_1_1InputStream.html">SR::InputStream&lt;SR::WeaverPositionStream&gt;</a> stream;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The accept function can process the weaver position data as soon as it becomes available</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> accept(<span class="keyword">const</span> <a class="code hl_struct" href="structSR__weaverPosition.html">SR_weaverPosition</a>&amp; frame)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Use WeaverTracker data</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Create WeaverTracker</span></div>
<div class="line">    <a class="code hl_class" href="classSR_1_1SRContext.html">SR::SRContext</a> context;</div>
</div><!-- fragment --><p >The <code>WeaverTracker::create</code> call is replaced with <code>PredictingWeaverTracker::create</code>.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classSR_1_1PredictingWeaverTracker.html">SR::PredictingWeaverTracker</a>* weaverTracker = <a class="code hl_function" href="classSR_1_1PredictingWeaverTracker.html#aae06298b0862319184ad450c122ea071">SR::PredictingWeaverTracker::create</a>(context);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Construct listener</span></div>
<div class="line">WeaverPositionListenerImplementation listener;</div>
<div class="line">listener.stream.set(weaverTracker-&gt;<a class="code hl_function" href="classSR_1_1PredictingWeaverTracker.html#a6ca8ebef940a950543be6f86f3e4ed49">openWeaverPositionStream</a>(&amp;listener));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Start tracking</span></div>
<div class="line">context.<a class="code hl_function" href="classSR_1_1SRContext.html#a6e889901b983ced27c24732fcae177c1">initialize</a>();</div>
<div class="ttc" id="aclassSR_1_1PredictingWeaverTracker_html"><div class="ttname"><a href="classSR_1_1PredictingWeaverTracker.html">SR::PredictingWeaverTracker</a></div><div class="ttdoc">Sense class which provides predictive weaver position tracking functionality.</div><div class="ttdef"><b>Definition:</b> predictingweavertracker.h:28</div></div>
<div class="ttc" id="aclassSR_1_1PredictingWeaverTracker_html_a6ca8ebef940a950543be6f86f3e4ed49"><div class="ttname"><a href="classSR_1_1PredictingWeaverTracker.html#a6ca8ebef940a950543be6f86f3e4ed49">SR::PredictingWeaverTracker::openWeaverPositionStream</a></div><div class="ttdeci">virtual std::shared_ptr&lt; WeaverPositionStream &gt; openWeaverPositionStream(WeaverPositionListener *listener) override</div><div class="ttdoc">Creates a WeaverPositionStream for listener to be connected to.</div></div>
<div class="ttc" id="aclassSR_1_1PredictingWeaverTracker_html_aae06298b0862319184ad450c122ea071"><div class="ttname"><a href="classSR_1_1PredictingWeaverTracker.html#aae06298b0862319184ad450c122ea071">SR::PredictingWeaverTracker::create</a></div><div class="ttdeci">static PredictingWeaverTracker * create(SRContext &amp;context)</div><div class="ttdoc">Returns a class of PredictingWeaverTracker.</div></div>
</div><!-- fragment --><p >To trigger the listener to receive new data the <code>predict</code> function can be called as follows.</p>
<div class="fragment"><div class="line">    <span class="comment">// Program loop</span></div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        weaverTracker-&gt;<a class="code hl_function" href="classSR_1_1PredictingWeaverTracker.html#a407ae467f92702649391271248937b0b">predict</a>(80);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Sleep in between predictions to simulate actual work being done in between frames</span></div>
<div class="line">        <span class="keyword">using namespace </span>std::chrono_literals;</div>
<div class="line">        std::this_thread::sleep_for(16ms);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassSR_1_1PredictingWeaverTracker_html_a407ae467f92702649391271248937b0b"><div class="ttname"><a href="classSR_1_1PredictingWeaverTracker.html#a407ae467f92702649391271248937b0b">SR::PredictingWeaverTracker::predict</a></div><div class="ttdeci">void predict(uint64_t latency, SR_weaverPosition &amp;output)</div><div class="ttdoc">Predict for a certain latency and trigger stream output Should not be used directly,...</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md61"></a>
Synchronous use of PredictingWeaverTracker</h2>
<p >In the above example, the work associated with filtering will be executed asynchronously. This can be useful to increase parallelization but might be difficult to control.</p>
<p >Since the <code>PredictingWeaverTracker</code> is an <code>EyePairListener</code> implementation. This still maintains a similar structure in your application. A single <code><a class="el" href="structSR__weaverPosition.html" title="C-compatible struct containing the weaver position.">SR_weaverPosition</a></code> is derived from the incoming unfiltered <code><a class="el" href="structSR__eyePair.html" title="C-compatible struct containing the position of two eyes.">SR_eyePair</a></code> data.</p>
<p >The developer does not have to define their own listener implementation in this case.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Create WeaverTracker</span></div>
<div class="line">    <a class="code hl_class" href="classSR_1_1SRContext.html">SR::SRContext</a> context;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classSR_1_1PredictingWeaverTracker.html">SR::PredictingWeaverTracker</a>* weaverTracker = <a class="code hl_function" href="classSR_1_1PredictingWeaverTracker.html#aae06298b0862319184ad450c122ea071">SR::PredictingWeaverTracker::create</a>(context);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Start tracking</span></div>
<div class="line">    context.<a class="code hl_function" href="classSR_1_1SRContext.html#a6e889901b983ced27c24732fcae177c1">initialize</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Program loop</span></div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        <a class="code hl_struct" href="structSR__weaverPosition.html">SR_weaverPosition</a> weaverPosition;</div>
<div class="line">        weaverTracker-&gt;<a class="code hl_function" href="classSR_1_1PredictingWeaverTracker.html#a407ae467f92702649391271248937b0b">predict</a>(80, eyePair);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Use WeaverTracker data</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Sleep in between predictions to simulate actual work being done in between frames</span></div>
<div class="line">        <span class="keyword">using namespace </span>std::chrono_literals;</div>
<div class="line">        std::this_thread::sleep_for(16ms);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>

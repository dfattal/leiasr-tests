<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LeiaSR SDK: SR::PredictingDX12Weaver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="extrastyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="sr-logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LeiaSR SDK<span id="projectnumber">&#160;3e4093ae v1.34.8.37806 2025-10-23T12:33:42Z</span>
   </div>
   <div id="projectbrief">Stable</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSR.html">SR</a></li><li class="navelem"><a class="el" href="classSR_1_1PredictingDX12Weaver.html">PredictingDX12Weaver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSR_1_1PredictingDX12Weaver-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SR::PredictingDX12Weaver Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="dx12weaver_8h_source.html">dx12weaver.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SR::PredictingDX12Weaver:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classSR_1_1PredictingDX12Weaver__inherit__graph.svg" width="190" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for SR::PredictingDX12Weaver:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classSR_1_1PredictingDX12Weaver__coll__graph.svg" width="190" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4a2bb21e5f75d7c5e968afd703c2725d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1PredictingDX12Weaver.html#a4a2bb21e5f75d7c5e968afd703c2725d">PredictingDX12Weaver</a> (<a class="el" href="classSR_1_1SRContext.html">SR::SRContext</a> &amp;context, ID3D12Device *device, ID3D12CommandAllocator *commandAllocator, ID3D12CommandQueue *commandQueue, ID3D12Resource *inputFramebuffer, ID3D12Resource *outputFramebuffer)</td></tr>
<tr class="memdesc:a4a2bb21e5f75d7c5e968afd703c2725d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a class to be used for weaving an input image of a certain size.  <a href="classSR_1_1PredictingDX12Weaver.html#a4a2bb21e5f75d7c5e968afd703c2725d">More...</a><br /></td></tr>
<tr class="separator:a4a2bb21e5f75d7c5e968afd703c2725d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f55a3376c1cf9ae9a8acb94f40ec79"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1PredictingDX12Weaver.html#aa4f55a3376c1cf9ae9a8acb94f40ec79">PredictingDX12Weaver</a> (<a class="el" href="classSR_1_1SRContext.html">SR::SRContext</a> &amp;context, ID3D12Device *device, ID3D12CommandAllocator *commandAllocator, ID3D12CommandQueue *commandQueue, ID3D12Resource *inputFramebuffer, ID3D12Resource *outputFramebuffer, <a class="el" href="IWeaverBase_8h.html#a644e41e016d857b27435091aa006b2ca">HWND</a> window)</td></tr>
<tr class="memdesc:aa4f55a3376c1cf9ae9a8acb94f40ec79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a class to be used for weaving an input image of a certain size.  <a href="classSR_1_1PredictingDX12Weaver.html#aa4f55a3376c1cf9ae9a8acb94f40ec79">More...</a><br /></td></tr>
<tr class="separator:aa4f55a3376c1cf9ae9a8acb94f40ec79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f22f0569414ad125dbe938a0c63ff9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1PredictingDX12Weaver.html#ac5f22f0569414ad125dbe938a0c63ff9">PredictingDX12Weaver</a> (<a class="el" href="classSR_1_1SRContext.html">SR::SRContext</a> &amp;context, ID3D12Device *device, ID3D12CommandAllocator *commandAllocator, ID3D12CommandQueue *commandQueue, ID3D12Resource *inputFramebuffer, ID3D12Resource *outputFramebuffer, <a class="el" href="IWeaverBase_8h.html#a644e41e016d857b27435091aa006b2ca">HWND</a> window, DXGI_FORMAT inputBufferViewFormat)</td></tr>
<tr class="memdesc:ac5f22f0569414ad125dbe938a0c63ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a class to be used for weaving an input image of a certain size This constructor should be used to specify the fully qualified format via <code>inputBufferViewFormat</code> when the <code>inputFramebuffer</code> is a texture created with a typeless format.  <a href="classSR_1_1PredictingDX12Weaver.html#ac5f22f0569414ad125dbe938a0c63ff9">More...</a><br /></td></tr>
<tr class="separator:ac5f22f0569414ad125dbe938a0c63ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7377050998cce2afc85b406543454235"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1PredictingDX12Weaver.html#a7377050998cce2afc85b406543454235">PredictingDX12Weaver</a> (<a class="el" href="classSR_1_1SRContext.html">SR::SRContext</a> &amp;context, ID3D12Device *device, ID3D12CommandAllocator *commandAllocator, ID3D12CommandQueue *commandQueue, ID3D12Resource *inputFramebuffer, ID3D12Resource *outputFramebuffer, <a class="el" href="IWeaverBase_8h.html#a644e41e016d857b27435091aa006b2ca">HWND</a> window, DXGI_FORMAT inputBufferViewFormat, DXGI_FORMAT outputFramebufferViewFormat)</td></tr>
<tr class="memdesc:a7377050998cce2afc85b406543454235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a class to be used for weaving an input image of a certain size This constructor should be used to specify the fully qualified format via <code>inputBufferViewFormat</code> when the <code>inputFramebuffer</code> is a texture created with a typeless format.  <a href="classSR_1_1PredictingDX12Weaver.html#a7377050998cce2afc85b406543454235">More...</a><br /></td></tr>
<tr class="separator:a7377050998cce2afc85b406543454235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9cdcb452a50cda264416c2a805f399"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1PredictingDX12Weaver.html#a1e9cdcb452a50cda264416c2a805f399">~PredictingDX12Weaver</a> ()</td></tr>
<tr class="memdesc:a1e9cdcb452a50cda264416c2a805f399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles proper destruction of all weaver related classes, buffers and references.  <a href="classSR_1_1PredictingDX12Weaver.html#a1e9cdcb452a50cda264416c2a805f399">More...</a><br /></td></tr>
<tr class="separator:a1e9cdcb452a50cda264416c2a805f399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8426772abeb21ee5dc204dc37083e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1PredictingDX12Weaver.html#a4e8426772abeb21ee5dc204dc37083e2">setLatency</a> (uint64_t latency)</td></tr>
<tr class="memdesc:a4e8426772abeb21ee5dc204dc37083e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the latency to match the expected duration of the full rendering pipeline.  <a href="classSR_1_1PredictingDX12Weaver.html#a4e8426772abeb21ee5dc204dc37083e2">More...</a><br /></td></tr>
<tr class="separator:a4e8426772abeb21ee5dc204dc37083e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf243f57ff87d2b6f3f51d300023b254"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1PredictingDX12Weaver.html#adf243f57ff87d2b6f3f51d300023b254">getLatency</a> ()</td></tr>
<tr class="memdesc:adf243f57ff87d2b6f3f51d300023b254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the latency that is used by the weaver. If setLatency has been called, the value set by that function will be returned. If setLatencyInFrames has been called, the latency will be calculated based on the refresh rate of the monitor and the application. By default setLatencyInFrames is used when no latency is explicitly set.  <a href="classSR_1_1PredictingDX12Weaver.html#adf243f57ff87d2b6f3f51d300023b254">More...</a><br /></td></tr>
<tr class="separator:adf243f57ff87d2b6f3f51d300023b254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c4d29d97fd8ed7ca6c92b1d7e4b9f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1PredictingDX12Weaver.html#a06c4d29d97fd8ed7ca6c92b1d7e4b9f6">setLatencyInFrames</a> (uint64_t latencyInFrames)</td></tr>
<tr class="memdesc:a06c4d29d97fd8ed7ca6c92b1d7e4b9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the latency to match the expected duration of the full rendering pipeline in number of frames. The latency in time is calculated using these number of frames based on the refresh rate of the monitor that the application is running on, this will be dynamically updated when the window changes monitor. For this it requires the weaver to be given a valid window handle of the running application.  <a href="classSR_1_1PredictingDX12Weaver.html#a06c4d29d97fd8ed7ca6c92b1d7e4b9f6">More...</a><br /></td></tr>
<tr class="separator:a06c4d29d97fd8ed7ca6c92b1d7e4b9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSR_1_1DX12WeaverBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSR_1_1DX12WeaverBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSR_1_1DX12WeaverBase.html">SR::DX12WeaverBase</a></td></tr>
<tr class="memitem:a9c8082a9f4e27178f9675a68f305c55a inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#a9c8082a9f4e27178f9675a68f305c55a">DX12WeaverBase</a> ()</td></tr>
<tr class="separator:a9c8082a9f4e27178f9675a68f305c55a inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469e8cd1f2bb279457dde8b3859498d6 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#a469e8cd1f2bb279457dde8b3859498d6">~DX12WeaverBase</a> ()</td></tr>
<tr class="separator:a469e8cd1f2bb279457dde8b3859498d6 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea8cdf353d2f8ce1a251c286ffed7df inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top">ID3D12Resource *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#a1ea8cdf353d2f8ce1a251c286ffed7df">getFrameBuffer</a> ()</td></tr>
<tr class="memdesc:a1ea8cdf353d2f8ce1a251c286ffed7df inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input buffer of the weaver. When weave(...) is called on this object, this buffer should contain a side-by-side view that will be used as input for the weaver.  <a href="classSR_1_1DX12WeaverBase.html#a1ea8cdf353d2f8ce1a251c286ffed7df">More...</a><br /></td></tr>
<tr class="separator:a1ea8cdf353d2f8ce1a251c286ffed7df inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3751a6247ccc4bb21e77a0f66f2488fc inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#a3751a6247ccc4bb21e77a0f66f2488fc">setInputFrameBuffer</a> (ID3D12Resource *frameBuffer)</td></tr>
<tr class="memdesc:a3751a6247ccc4bb21e77a0f66f2488fc inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the input buffer of the weaver. When weave(...) is called on this object, this buffer should contain a side-by-side view that will be used as input for the weaver.  <a href="classSR_1_1DX12WeaverBase.html#a3751a6247ccc4bb21e77a0f66f2488fc">More...</a><br /></td></tr>
<tr class="separator:a3751a6247ccc4bb21e77a0f66f2488fc inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18068bd9bbc5f28765e596f14cc030da inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#a18068bd9bbc5f28765e596f14cc030da">setInputFrameBuffer</a> (ID3D12Resource *frameBuffer, DXGI_FORMAT bufferViewFormat)</td></tr>
<tr class="memdesc:a18068bd9bbc5f28765e596f14cc030da inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the input buffer of the weaver. This overload of the function should be used to specify the fully qualified format via <code>bufferViewFormat</code> when the <code>framebuffer</code> is a texture created with a typeless format When weave(...) is called on this object, this buffer should contain a side-by-side view that will be used as input for the weaver.  <a href="classSR_1_1DX12WeaverBase.html#a18068bd9bbc5f28765e596f14cc030da">More...</a><br /></td></tr>
<tr class="separator:a18068bd9bbc5f28765e596f14cc030da inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c497b380e0a9500d55362547e5db010 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#a5c497b380e0a9500d55362547e5db010">setOutputFrameBuffer</a> (ID3D12Resource *frameBuffer)</td></tr>
<tr class="memdesc:a5c497b380e0a9500d55362547e5db010 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the output buffer of the weaver. After weave(...) has been called on this object, the weaved image will be written to this buffer.  <a href="classSR_1_1DX12WeaverBase.html#a5c497b380e0a9500d55362547e5db010">More...</a><br /></td></tr>
<tr class="separator:a5c497b380e0a9500d55362547e5db010 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475aef587706c8e16afbfb1400eec49d inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#a475aef587706c8e16afbfb1400eec49d">setCommandList</a> (ID3D12GraphicsCommandList *commandList)</td></tr>
<tr class="memdesc:a475aef587706c8e16afbfb1400eec49d inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the command list for the weaver to use. Must be set before the <a class="el" href="classSR_1_1DX12WeaverBase.html#aaab438e919354f11d421f8d26ef6e0be" title="Can be called to render a weaved image of inputFramebuffer provided to DX12Weaver::DX12Weaver(....">weave()</a> function can be called.  <a href="classSR_1_1DX12WeaverBase.html#a475aef587706c8e16afbfb1400eec49d">More...</a><br /></td></tr>
<tr class="separator:a475aef587706c8e16afbfb1400eec49d inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619575a0160e41b8fa697ed87af25699 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#a619575a0160e41b8fa697ed87af25699">setWindowHandle</a> (<a class="el" href="IWeaverBase_8h.html#a644e41e016d857b27435091aa006b2ca">HWND</a> handle)</td></tr>
<tr class="memdesc:a619575a0160e41b8fa697ed87af25699 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the window handle of the application window. If the weaver was created using a deprecated constructor, setting window handle has no effect.  <a href="classSR_1_1DX12WeaverBase.html#a619575a0160e41b8fa697ed87af25699">More...</a><br /></td></tr>
<tr class="separator:a619575a0160e41b8fa697ed87af25699 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d60799d2b094468207aec831acfcce inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#a74d60799d2b094468207aec831acfcce">setContrast</a> (float contrast)</td></tr>
<tr class="memdesc:a74d60799d2b094468207aec831acfcce inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the weaving contrast.  <a href="classSR_1_1DX12WeaverBase.html#a74d60799d2b094468207aec831acfcce">More...</a><br /></td></tr>
<tr class="separator:a74d60799d2b094468207aec831acfcce inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c89c4c58fd72568ce75375ee1c0f7c inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#a09c89c4c58fd72568ce75375ee1c0f7c">getContrast</a> () const</td></tr>
<tr class="memdesc:a09c89c4c58fd72568ce75375ee1c0f7c inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current weaving contrast.  <a href="classSR_1_1DX12WeaverBase.html#a09c89c4c58fd72568ce75375ee1c0f7c">More...</a><br /></td></tr>
<tr class="separator:a09c89c4c58fd72568ce75375ee1c0f7c inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b40fc1b974af0e31dcee9bb59ce9c2 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#a56b40fc1b974af0e31dcee9bb59ce9c2">setShaderSRGBConversion</a> (bool read, bool write)</td></tr>
<tr class="memdesc:a56b40fc1b974af0e31dcee9bb59ce9c2 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether to apply shader sRGB&lt;-&gt;Linear color space conversions to the input framebuffer during weaving.  <a href="classSR_1_1DX12WeaverBase.html#a56b40fc1b974af0e31dcee9bb59ce9c2">More...</a><br /></td></tr>
<tr class="separator:a56b40fc1b974af0e31dcee9bb59ce9c2 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee70b96e6591df8f994bd631948a870a inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#aee70b96e6591df8f994bd631948a870a">setACTMode</a> (<a class="el" href="WeaverTypes_8h.html#ae2250a72b5f7d901de8ea98cb1f9e868">WeaverACTMode</a> mode)</td></tr>
<tr class="memdesc:aee70b96e6591df8f994bd631948a870a inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the anti-crosstalk mode.  <a href="classSR_1_1DX12WeaverBase.html#aee70b96e6591df8f994bd631948a870a">More...</a><br /></td></tr>
<tr class="separator:aee70b96e6591df8f994bd631948a870a inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26fdf9c483dba8d41ad6ce112ae02ffb inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="WeaverTypes_8h.html#ae2250a72b5f7d901de8ea98cb1f9e868">WeaverACTMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#a26fdf9c483dba8d41ad6ce112ae02ffb">getACTMode</a> () const</td></tr>
<tr class="memdesc:a26fdf9c483dba8d41ad6ce112ae02ffb inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the anti-crosstalk mode.  <a href="classSR_1_1DX12WeaverBase.html#a26fdf9c483dba8d41ad6ce112ae02ffb">More...</a><br /></td></tr>
<tr class="separator:a26fdf9c483dba8d41ad6ce112ae02ffb inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f73d38f2a3c4b6e45ee826e7ef9ab75 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#a5f73d38f2a3c4b6e45ee826e7ef9ab75">setCrosstalkStaticFactor</a> (float factor)</td></tr>
<tr class="memdesc:a5f73d38f2a3c4b6e45ee826e7ef9ab75 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the anti-crosstalk factor.  <a href="classSR_1_1DX12WeaverBase.html#a5f73d38f2a3c4b6e45ee826e7ef9ab75">More...</a><br /></td></tr>
<tr class="separator:a5f73d38f2a3c4b6e45ee826e7ef9ab75 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56b49d0f464d156e3a11850b397711c inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#ae56b49d0f464d156e3a11850b397711c">getCrosstalkStaticFactor</a> () const</td></tr>
<tr class="memdesc:ae56b49d0f464d156e3a11850b397711c inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the anti-crosstalk factor.  <a href="classSR_1_1DX12WeaverBase.html#ae56b49d0f464d156e3a11850b397711c">More...</a><br /></td></tr>
<tr class="separator:ae56b49d0f464d156e3a11850b397711c inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb69c2980ea75b00aeed50efb0769a5 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#accb69c2980ea75b00aeed50efb0769a5">setCrosstalkDynamicFactor</a> (float factor)</td></tr>
<tr class="memdesc:accb69c2980ea75b00aeed50efb0769a5 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the anti-crosstalk dynamic factor.  <a href="classSR_1_1DX12WeaverBase.html#accb69c2980ea75b00aeed50efb0769a5">More...</a><br /></td></tr>
<tr class="separator:accb69c2980ea75b00aeed50efb0769a5 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b1f742921bfee4951ce66550d15dde inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#a89b1f742921bfee4951ce66550d15dde">getCrosstalkDynamicFactor</a> () const</td></tr>
<tr class="memdesc:a89b1f742921bfee4951ce66550d15dde inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the anti-crosstalk dynamic factor.  <a href="classSR_1_1DX12WeaverBase.html#a89b1f742921bfee4951ce66550d15dde">More...</a><br /></td></tr>
<tr class="separator:a89b1f742921bfee4951ce66550d15dde inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ac1d50827ad5547b35a6f6375aa584 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#a30ac1d50827ad5547b35a6f6375aa584">canWeave</a> ()</td></tr>
<tr class="memdesc:a30ac1d50827ad5547b35a6f6375aa584 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to determine if software weaving is possible on this device. Always returns false if the input or output buffer is not set.  <a href="classSR_1_1DX12WeaverBase.html#a30ac1d50827ad5547b35a6f6375aa584">More...</a><br /></td></tr>
<tr class="separator:a30ac1d50827ad5547b35a6f6375aa584 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6fe6f2014568d732f78f48a3c18da3 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#a1a6fe6f2014568d732f78f48a3c18da3">canWeave</a> (unsigned int width, unsigned int height)</td></tr>
<tr class="memdesc:a1a6fe6f2014568d732f78f48a3c18da3 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to determine if software weaving is possible for certain size and visibility to the currently bound framebuffer. Always returns false if the input or output buffer is not set.  <a href="classSR_1_1DX12WeaverBase.html#a1a6fe6f2014568d732f78f48a3c18da3">More...</a><br /></td></tr>
<tr class="separator:a1a6fe6f2014568d732f78f48a3c18da3 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a66a3983b87e13aab2b3bf67925cd17 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#a1a66a3983b87e13aab2b3bf67925cd17">canWeave</a> (unsigned int width, unsigned int height, unsigned int xOffset, unsigned int yOffset)</td></tr>
<tr class="memdesc:a1a66a3983b87e13aab2b3bf67925cd17 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to determine if software weaving is possible for certain size and visibility to the currently bound framebuffer. Always returns false if the input or output buffer is not set.  <a href="classSR_1_1DX12WeaverBase.html#a1a66a3983b87e13aab2b3bf67925cd17">More...</a><br /></td></tr>
<tr class="separator:a1a66a3983b87e13aab2b3bf67925cd17 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab438e919354f11d421f8d26ef6e0be inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#aaab438e919354f11d421f8d26ef6e0be">weave</a> (unsigned int width, unsigned int height)</td></tr>
<tr class="memdesc:aaab438e919354f11d421f8d26ef6e0be inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be called to render a weaved image of <code>inputFramebuffer</code> provided to <code>DX12Weaver::DX12Weaver(...)</code> (Must be D3D12_RESOURCE_STATE_UNORDERED_ACCESS) to the currently bound rendertarget (Must be D3D12_RESOURCE_STATE_RENDER_TARGET) A commandlist must be set before calling this function or weaving will not be executed.  <a href="classSR_1_1DX12WeaverBase.html#aaab438e919354f11d421f8d26ef6e0be">More...</a><br /></td></tr>
<tr class="separator:aaab438e919354f11d421f8d26ef6e0be inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca77291f2cfcb5438e4fc001031bb6b inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#a7ca77291f2cfcb5438e4fc001031bb6b">weave</a> (unsigned int width, unsigned int height, unsigned int xOffset, unsigned int yOffset)</td></tr>
<tr class="memdesc:a7ca77291f2cfcb5438e4fc001031bb6b inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be called to render a weaved image of <code>inputFramebuffer</code> provided to <code>DX12Weaver::DX12Weaver(...)</code> (Must be D3D12_RESOURCE_STATE_UNORDERED_ACCESS) to the currently bound rendertarget (Must be D3D12_RESOURCE_STATE_RENDER_TARGET) A commandlist must be set before calling this function or weaving will not be executed.  <a href="classSR_1_1DX12WeaverBase.html#a7ca77291f2cfcb5438e4fc001031bb6b">More...</a><br /></td></tr>
<tr class="separator:a7ca77291f2cfcb5438e4fc001031bb6b inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef70c26575684da4cc993f7b699d2e6 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#a8ef70c26575684da4cc993f7b699d2e6">weave</a> (ID3D12GraphicsCommandList *commandList, unsigned int width, unsigned int height)</td></tr>
<tr class="memdesc:a8ef70c26575684da4cc993f7b699d2e6 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be called to render a weaved image of <code>inputFramebuffer</code> provided to <code>DX12Weaver::DX12Weaver(...)</code> (Must be D3D12_RESOURCE_STATE_UNORDERED_ACCESS) to the currently bound rendertarget (Must be D3D12_RESOURCE_STATE_RENDER_TARGET)  <a href="classSR_1_1DX12WeaverBase.html#a8ef70c26575684da4cc993f7b699d2e6">More...</a><br /></td></tr>
<tr class="separator:a8ef70c26575684da4cc993f7b699d2e6 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba1725a42ac55585ca093d492347dc9 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#a1ba1725a42ac55585ca093d492347dc9">weave</a> (ID3D12GraphicsCommandList *commandList, unsigned int width, unsigned int height, unsigned int xOffset, unsigned int yOffset)</td></tr>
<tr class="memdesc:a1ba1725a42ac55585ca093d492347dc9 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Can be called to render a weaved image of <code>inputFramebuffer</code> provided to <code>DX12Weaver::DX12Weaver(...)</code> (Must be D3D12_RESOURCE_STATE_UNORDERED_ACCESS) to the currently bound rendertarget (Must be D3D12_RESOURCE_STATE_RENDER_TARGET)  <a href="classSR_1_1DX12WeaverBase.html#a1ba1725a42ac55585ca093d492347dc9">More...</a><br /></td></tr>
<tr class="separator:a1ba1725a42ac55585ca093d492347dc9 inherit pub_methods_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_classSR_1_1DX12WeaverBase"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classSR_1_1DX12WeaverBase')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classSR_1_1DX12WeaverBase.html">SR::DX12WeaverBase</a></td></tr>
<tr class="memitem:a3451341a6ddc063a18eaf6bbea8d1d5b inherit pro_attribs_classSR_1_1DX12WeaverBase"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; Impl &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSR_1_1DX12WeaverBase.html#a3451341a6ddc063a18eaf6bbea8d1d5b">pimpl</a></td></tr>
<tr class="separator:a3451341a6ddc063a18eaf6bbea8d1d5b inherit pro_attribs_classSR_1_1DX12WeaverBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4a2bb21e5f75d7c5e968afd703c2725d" name="a4a2bb21e5f75d7c5e968afd703c2725d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2bb21e5f75d7c5e968afd703c2725d">&#9670;&nbsp;</a></span>PredictingDX12Weaver() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SR::PredictingDX12Weaver::PredictingDX12Weaver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSR_1_1SRContext.html">SR::SRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12Device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12CommandAllocator *&#160;</td>
          <td class="paramname"><em>commandAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12CommandQueue *&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12Resource *&#160;</td>
          <td class="paramname"><em>inputFramebuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12Resource *&#160;</td>
          <td class="paramname"><em>outputFramebuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a class to be used for weaving an input image of a certain size. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>to connect to, needs to be valid for the lifetime of the weaver object. </td></tr>
    <tr><td class="paramname">device</td><td>interface used to create resources </td></tr>
    <tr><td class="paramname">commandAllocator</td><td>used for command list generation during setup </td></tr>
    <tr><td class="paramname">commandQueue</td><td>used for command list execution during setup </td></tr>
    <tr><td class="paramname">inputFramebuffer</td><td>A pointer to a frame buffer resource containing the side-by-side image to be weaved together. A reference to this resource will be maintained by the object until a different input buffer is set by calling setInputFrameBuffer or until the object is destroyed. </td></tr>
    <tr><td class="paramname">outputFramebuffer</td><td>A pointer to a frame buffer resource where the output of the weaver will be written to (usually the backbuffer). No reference to the output framebuffer is kept by the weaver object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>inputFramebuffer</code> is a texture resource created with a typeless format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4f55a3376c1cf9ae9a8acb94f40ec79" name="aa4f55a3376c1cf9ae9a8acb94f40ec79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f55a3376c1cf9ae9a8acb94f40ec79">&#9670;&nbsp;</a></span>PredictingDX12Weaver() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SR::PredictingDX12Weaver::PredictingDX12Weaver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSR_1_1SRContext.html">SR::SRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12Device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12CommandAllocator *&#160;</td>
          <td class="paramname"><em>commandAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12CommandQueue *&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12Resource *&#160;</td>
          <td class="paramname"><em>inputFramebuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12Resource *&#160;</td>
          <td class="paramname"><em>outputFramebuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="IWeaverBase_8h.html#a644e41e016d857b27435091aa006b2ca">HWND</a>&#160;</td>
          <td class="paramname"><em>window</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a class to be used for weaving an input image of a certain size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>to connect to, needs to be valid for the lifetime of the weaver object. </td></tr>
    <tr><td class="paramname">device</td><td>interface used to create resources </td></tr>
    <tr><td class="paramname">commandAllocator</td><td>used for command list generation during setup </td></tr>
    <tr><td class="paramname">commandQueue</td><td>used for command list execution during setup </td></tr>
    <tr><td class="paramname">inputFramebuffer</td><td>A pointer to a frame buffer resource containing the side-by-side image to be weaved together. A reference to this resource will be maintained by the object until a different input buffer is set by calling setInputFrameBuffer or until the object is destroyed. </td></tr>
    <tr><td class="paramname">outputFramebuffer</td><td>A pointer to a frame buffer resource where the output of the weaver will be written to (usually the backbuffer). No reference to the output framebuffer is kept by the weaver object. </td></tr>
    <tr><td class="paramname">window</td><td>Handle of the application window </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>inputFramebuffer</code> is a texture resource created with a typeless format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5f22f0569414ad125dbe938a0c63ff9" name="ac5f22f0569414ad125dbe938a0c63ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f22f0569414ad125dbe938a0c63ff9">&#9670;&nbsp;</a></span>PredictingDX12Weaver() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SR::PredictingDX12Weaver::PredictingDX12Weaver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSR_1_1SRContext.html">SR::SRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12Device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12CommandAllocator *&#160;</td>
          <td class="paramname"><em>commandAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12CommandQueue *&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12Resource *&#160;</td>
          <td class="paramname"><em>inputFramebuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12Resource *&#160;</td>
          <td class="paramname"><em>outputFramebuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="IWeaverBase_8h.html#a644e41e016d857b27435091aa006b2ca">HWND</a>&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DXGI_FORMAT&#160;</td>
          <td class="paramname"><em>inputBufferViewFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a class to be used for weaving an input image of a certain size This constructor should be used to specify the fully qualified format via <code>inputBufferViewFormat</code> when the <code>inputFramebuffer</code> is a texture created with a typeless format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>to connect to, needs to be valid for the lifetime of the weaver object. </td></tr>
    <tr><td class="paramname">device</td><td>interface used to create resources </td></tr>
    <tr><td class="paramname">commandAllocator</td><td>used for command list generation during setup </td></tr>
    <tr><td class="paramname">commandQueue</td><td>used for command list execution during setup </td></tr>
    <tr><td class="paramname">inputFramebuffer</td><td>A pointer to a frame buffer resource containing the side-by-side image to be weaved together. A reference to this resource will be maintained by the object until a different input buffer is set by calling setInputFrameBuffer or until the object is destroyed. </td></tr>
    <tr><td class="paramname">outputFramebuffer</td><td>A pointer to a frame buffer resource where the output of the weaver will be written to (usually the backbuffer). No reference to the output framebuffer is kept by the weaver object. </td></tr>
    <tr><td class="paramname">window</td><td>Handle of the application window </td></tr>
    <tr><td class="paramname">inputBufferViewFormat</td><td>The fully qualified shader resource view format for the input frame buffer. This specification is required for textures created with typeless format. It can also be used to cast an already specified fully qualified format to another. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>inputFramebuffer</code> is a texture resource created with a typeless format and <code>inputBufferViewFormat</code>'s value is DXGI_FORMAT_UNKNOWN </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7377050998cce2afc85b406543454235" name="a7377050998cce2afc85b406543454235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7377050998cce2afc85b406543454235">&#9670;&nbsp;</a></span>PredictingDX12Weaver() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SR::PredictingDX12Weaver::PredictingDX12Weaver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSR_1_1SRContext.html">SR::SRContext</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12Device *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12CommandAllocator *&#160;</td>
          <td class="paramname"><em>commandAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12CommandQueue *&#160;</td>
          <td class="paramname"><em>commandQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12Resource *&#160;</td>
          <td class="paramname"><em>inputFramebuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12Resource *&#160;</td>
          <td class="paramname"><em>outputFramebuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="IWeaverBase_8h.html#a644e41e016d857b27435091aa006b2ca">HWND</a>&#160;</td>
          <td class="paramname"><em>window</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DXGI_FORMAT&#160;</td>
          <td class="paramname"><em>inputBufferViewFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DXGI_FORMAT&#160;</td>
          <td class="paramname"><em>outputFramebufferViewFormat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a class to be used for weaving an input image of a certain size This constructor should be used to specify the fully qualified format via <code>inputBufferViewFormat</code> when the <code>inputFramebuffer</code> is a texture created with a typeless format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>to connect to, needs to be valid for the lifetime of the weaver object. </td></tr>
    <tr><td class="paramname">device</td><td>interface used to create resources </td></tr>
    <tr><td class="paramname">commandAllocator</td><td>used for command list generation during setup </td></tr>
    <tr><td class="paramname">commandQueue</td><td>used for command list execution during setup </td></tr>
    <tr><td class="paramname">inputFramebuffer</td><td>A pointer to a frame buffer resource containing the side-by-side image to be weaved together. A reference to this resource will be maintained by the object until a different input buffer is set by calling setInputFrameBuffer or until the object is destroyed. </td></tr>
    <tr><td class="paramname">outputFramebuffer</td><td>A pointer to a frame buffer resource where the output of the weaver will be written to (usually the backbuffer). No reference to the output framebuffer is kept by the weaver object. </td></tr>
    <tr><td class="paramname">window</td><td>Handle of the application window </td></tr>
    <tr><td class="paramname">inputBufferViewFormat</td><td>The fully qualified shader resource view format for the input frame buffer. This specification is required for textures created with typeless format. It can also be used to cast an already specified fully qualified format to another. </td></tr>
    <tr><td class="paramname">outputFramebufferViewFormat</td><td>The fully qualified shader resource view format for the output frame buffer view. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::exception</td><td>if <code>inputFramebuffer</code> is a texture resource created with a typeless format and <code>inputBufferViewFormat</code>'s value is DXGI_FORMAT_UNKNOWN </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e9cdcb452a50cda264416c2a805f399" name="a1e9cdcb452a50cda264416c2a805f399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9cdcb452a50cda264416c2a805f399">&#9670;&nbsp;</a></span>~PredictingDX12Weaver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SR::PredictingDX12Weaver::~PredictingDX12Weaver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles proper destruction of all weaver related classes, buffers and references. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adf243f57ff87d2b6f3f51d300023b254" name="adf243f57ff87d2b6f3f51d300023b254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf243f57ff87d2b6f3f51d300023b254">&#9670;&nbsp;</a></span>getLatency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t SR::PredictingDX12Weaver::getLatency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the latency that is used by the weaver. If setLatency has been called, the value set by that function will be returned. If setLatencyInFrames has been called, the latency will be calculated based on the refresh rate of the monitor and the application. By default setLatencyInFrames is used when no latency is explicitly set. </p>
<dl class="section return"><dt>Returns</dt><dd>The latency in microseconds </dd></dl>

</div>
</div>
<a id="a4e8426772abeb21ee5dc204dc37083e2" name="a4e8426772abeb21ee5dc204dc37083e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8426772abeb21ee5dc204dc37083e2">&#9670;&nbsp;</a></span>setLatency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SR::PredictingDX12Weaver::setLatency </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>latency</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the latency to match the expected duration of the full rendering pipeline. </p>
<p >The eye positions should be predicted to the timepoint at which the frame is visible to the user Internally the prediction is already taking care of all other latency, only the rendering pipeline latency is application dependent A low latency app would have 1 framebuffer latency, so 16666 microseconds (the generated frame will be presented at next v-sync) When using v-sync, the driver adds at least 1 buffer latency, and maybe the windows display manager also adds a buffer latency. Typically, the latency is n * 1000*1000/framerate microseconds</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">latency</td><td>The latency from the moment when <a class="el" href="classSR_1_1DX12WeaverBase.html#aaab438e919354f11d421f8d26ef6e0be" title="Can be called to render a weaved image of inputFramebuffer provided to DX12Weaver::DX12Weaver(....">weave()</a> is called until presenting the current frame to the user, in microseconds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06c4d29d97fd8ed7ca6c92b1d7e4b9f6" name="a06c4d29d97fd8ed7ca6c92b1d7e4b9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c4d29d97fd8ed7ca6c92b1d7e4b9f6">&#9670;&nbsp;</a></span>setLatencyInFrames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SR::PredictingDX12Weaver::setLatencyInFrames </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>latencyInFrames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the latency to match the expected duration of the full rendering pipeline in number of frames. The latency in time is calculated using these number of frames based on the refresh rate of the monitor that the application is running on, this will be dynamically updated when the window changes monitor. For this it requires the weaver to be given a valid window handle of the running application. </p>
<p >The eye positions should be predicted to the timepoint at which the frame is visible to the user Internally the prediction is already taking care of all other latency, only the rendering pipeline latency is application dependent A low latency app would have 1 framebuffer latency, the generated frame will be presented at next v-sync) When using v-sync, the driver adds at least 1 buffer latency, and maybe the windows display manager also adds a buffer latency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">latencyInFrames</td><td>The expected number of frames before presenting the current generated frame to the user. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="dx12weaver_8h_source.html">dx12weaver.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>

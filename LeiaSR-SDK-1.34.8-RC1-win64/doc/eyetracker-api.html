<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LeiaSR SDK: EyeTracker API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="extrastyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="sr-logo.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LeiaSR SDK<span id="projectnumber">&#160;3e4093ae v1.34.8.37806 2025-10-23T12:33:42Z</span>
   </div>
   <div id="projectbrief">Stable</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">EyeTracker API </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_C__GitLabRunner_builds_fe33718a_0_simulatedreality_simulatedreality_modules_srFacetrackers_documentation_public_eyetracker_api"></a> </p>
<h1><a class="anchor" id="autotoc_md44"></a>
Classes</h1>
<p >The user only has to interact with fixed interfaces offering different features. The EyeTracker interface is one of the most essential <a class="el" href="namespaceSR.html" title="Namespace containing all C++ Simulated Reality classes.">SR</a> components. In this class diagram, only the user-facing classes are visualized.</p>
<ul>
<li><code>SRContext</code> is an essential element of any <a class="el" href="namespaceSR.html" title="Namespace containing all C++ Simulated Reality classes.">SR</a> application, it maintains a list of all <a class="el" href="namespaceSR.html" title="Namespace containing all C++ Simulated Reality classes.">SR</a> components that are in use and cleans them up when the application ends. It also allows different components of the application to share the same Sense implementations.</li>
<li><code>Sense</code> is an interface used by the <code>SRContext</code> to keep track of any input or output devices.</li>
<li><code>EyeTracker</code> is an interface providing access to eyetracker data.</li>
<li><code>EyePairStream</code> connects <code>EyeTracker</code> implementations with user defined <code>EyePairListener</code> implementations.</li>
<li><code>EyePairListener</code> is an interface to be implemented by any components of the user's application that want to receive eyetracker data.</li>
<li><code><a class="el" href="structSR__eyePair.html" title="C-compatible struct containing the position of two eyes.">SR_eyePair</a></code> defines the actual eyetracker data.</li>
</ul>
<p ><img src="eyetrackerclassdiagram.svg" alt="" style="pointer-events: none;" class="inline" title="External class diagram"/></p>
<h2><a class="anchor" id="autotoc_md45"></a>
EyeTracker Data</h2>
<p >The <a class="el" href="structSR__eyePair.html" title="C-compatible struct containing the position of two eyes.">SR_eyePair</a> is at the center of the EyeTracker interface, this is what applications can subscribe to.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    uint64_t frameId; </div>
<div class="line">    uint64_t time;    </div>
<div class="line">    <a class="code hl_union" href="unionSR__vector3d.html">SR_point3d</a> left;  </div>
<div class="line">    <a class="code hl_union" href="unionSR__vector3d.html">SR_point3d</a> right; </div>
<div class="line">} <a class="code hl_struct" href="structSR__eyePair.html">SR_eyePair</a>;</div>
<div class="ttc" id="astructSR__eyePair_html"><div class="ttname"><a href="structSR__eyePair.html">SR_eyePair</a></div><div class="ttdoc">C-compatible struct containing the position of two eyes.</div><div class="ttdef"><b>Definition:</b> eyepair.h:23</div></div>
<div class="ttc" id="aunionSR__vector3d_html"><div class="ttname"><a href="unionSR__vector3d.html">SR_vector3d</a></div><div class="ttdoc">C-compatible 3d double vector representation.</div><div class="ttdef"><b>Definition:</b> types.h:73</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md46"></a>
EyeTracker usage</h1>
<p >Application developers should define how to handle the EyeTracker data by implementing an <code>EyePairListener</code>. It is advisable to include an <code>InputStream&lt;<a class="el" href="classSR_1_1EyePairStream.html" title="Stream of SR_eyePair objects.">SR::EyePairStream</a>&gt;</code> member, this will come into play when the actual eye tracker is constructed.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>EyePairListenerImplementation : <span class="keyword">public</span> <a class="code hl_class" href="classSR_1_1EyePairListener.html">SR::EyePairListener</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Ensures EyePairStream is cleaned up when Listener object is out of scope</span></div>
<div class="line">    <a class="code hl_class" href="classSR_1_1InputStream.html">SR::InputStream&lt;SR::EyePairStream&gt;</a> stream;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The accept function can process the eye position data as soon as it becomes available</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code hl_function" href="classSR_1_1EyePairListener.html#a2fac6e297689062fc110ebfd1e44f4f5">accept</a>(<span class="keyword">const</span> <a class="code hl_struct" href="structSR__eyePair.html">SR_eyePair</a>&amp; frame)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Use EyeTracker data</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aclassSR_1_1EyePairListener_html"><div class="ttname"><a href="classSR_1_1EyePairListener.html">SR::EyePairListener</a></div><div class="ttdoc">Interface for listening to SR_eyePair updates.</div><div class="ttdef"><b>Definition:</b> eyepairlistener.h:15</div></div>
<div class="ttc" id="aclassSR_1_1EyePairListener_html_a2fac6e297689062fc110ebfd1e44f4f5"><div class="ttname"><a href="classSR_1_1EyePairListener.html#a2fac6e297689062fc110ebfd1e44f4f5">SR::EyePairListener::accept</a></div><div class="ttdeci">virtual void accept(const SR_eyePair &amp;frame)=0</div><div class="ttdoc">Accept an SR_eyePair frame.</div></div>
<div class="ttc" id="aclassSR_1_1InputStream_html"><div class="ttname"><a href="classSR_1_1InputStream.html">SR::InputStream</a></div><div class="ttdoc">Template class to wrap data stream to a listener object.</div><div class="ttdef"><b>Definition:</b> inputstream.h:20</div></div>
</div><!-- fragment --><p> To get access to eyetracker data, users will have to construct an SRContext and call the static factory function <code>EyeTracker::create</code> as follows:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Create EyeTracker</span></div>
<div class="line">    <a class="code hl_class" href="classSR_1_1SRContext.html">SR::SRContext</a> context;</div>
<div class="line">    <a class="code hl_class" href="classSR_1_1EyeTracker.html">SR::EyeTracker</a>* eyeTracker = <a class="code hl_function" href="classSR_1_1EyeTracker.html#a0f0ebb342ec5dd5fb63178c07be0b333">SR::EyeTracker::create</a>(context);</div>
<div class="ttc" id="aclassSR_1_1EyeTracker_html"><div class="ttname"><a href="classSR_1_1EyeTracker.html">SR::EyeTracker</a></div><div class="ttdoc">Sense class which provides face tracking functionality to the SR system.</div><div class="ttdef"><b>Definition:</b> eyetracker.h:35</div></div>
<div class="ttc" id="aclassSR_1_1EyeTracker_html_a0f0ebb342ec5dd5fb63178c07be0b333"><div class="ttname"><a href="classSR_1_1EyeTracker.html#a0f0ebb342ec5dd5fb63178c07be0b333">SR::EyeTracker::create</a></div><div class="ttdeci">static EyeTracker * create(SRContext &amp;context)</div><div class="ttdoc">Creates a functional EyeTracker instance.</div></div>
<div class="ttc" id="aclassSR_1_1SRContext_html"><div class="ttname"><a href="classSR_1_1SRContext.html">SR::SRContext</a></div><div class="ttdoc">Maintains WorldObject and Sense objects during the application lifetime.</div><div class="ttdef"><b>Definition:</b> srcontext.h:75</div></div>
</div><!-- fragment --><p >Then we need to construct a listener that follows the desired way of processing the data. By calling <code>set</code> on the <code>InputStream&lt;<a class="el" href="classSR_1_1EyePairStream.html" title="Stream of SR_eyePair objects.">SR::EyePairStream</a>&gt;</code> field we ensure that the stream is destructed correctly when the <code>EyePairListenerImplementation</code> goes out of scope. When everything is set up <code>context.initialize()</code> starts using any newly constructed streams to listeners.</p>
<div class="fragment"><div class="line"><span class="comment">// Construct listener</span></div>
<div class="line">EyePairListenerImplementation listener;</div>
<div class="line">listener.stream.set(eyeTracker-&gt;<a class="code hl_function" href="classSR_1_1EyeTracker.html#aea7230f14d499c4a65e6ae3665867fdd">openEyePairStream</a>(&amp;listener));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Start tracking</span></div>
<div class="line">context.<a class="code hl_function" href="classSR_1_1SRContext.html#a6e889901b983ced27c24732fcae177c1">initialize</a>();</div>
<div class="ttc" id="aclassSR_1_1EyeTracker_html_aea7230f14d499c4a65e6ae3665867fdd"><div class="ttname"><a href="classSR_1_1EyeTracker.html#aea7230f14d499c4a65e6ae3665867fdd">SR::EyeTracker::openEyePairStream</a></div><div class="ttdeci">virtual std::shared_ptr&lt; EyePairStream &gt; openEyePairStream(EyePairListener *listener)=0</div><div class="ttdoc">Creates a EyePairStream for listener to be connected to.</div></div>
<div class="ttc" id="aclassSR_1_1SRContext_html_a6e889901b983ced27c24732fcae177c1"><div class="ttname"><a href="classSR_1_1SRContext.html#a6e889901b983ced27c24732fcae177c1">SR::SRContext::initialize</a></div><div class="ttdeci">void initialize()</div><div class="ttdoc">Initialize all senses.</div></div>
</div><!-- fragment --><p >If the main function of our application returns, all deconstructors will be called and we will no longer receive data. We should ensure that the application remains open as long as we want.</p>
<div class="fragment"><div class="line">    <span class="comment">// Ensure that the program does not exit immediately.</span></div>
<div class="line">    <span class="keywordtype">char</span> inchar;</div>
<div class="line">    std::cin &gt;&gt; inchar; <span class="comment">//wait for key press</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md47"></a>
Prediction</h1>
<p >To ensure that your application is as responsive as possible a specific <code>EyeTracker</code> implementation can be constructed. The following is a short description of relevant classes.</p>
<ul>
<li><code>PredictingEyeTracker</code> is an implementation of the <code>EyeTracker</code> interface that offers more control over the filtering of the output values to the application developer.</li>
<li><code>EyePairPredictor</code> is an implementation of the <code>PredictiveFilter&lt;<a class="el" href="structSR__eyePair.html" title="C-compatible struct containing the position of two eyes.">SR_eyePair</a>, uint64_t&gt;</code> interface that defines how <code><a class="el" href="structSR__eyePair.html" title="C-compatible struct containing the position of two eyes.">SR_eyePair</a></code> data is filtered to provide accurate predictions.</li>
</ul>
<p ><img src="predictingeyetrackerclassdiagram.svg" alt="" style="pointer-events: none;" class="inline" title="External class diagram"/></p>
<h1><a class="anchor" id="autotoc_md48"></a>
PredictingEyeTracker usage</h1>
<p >The <code>PredictingEyeTracker::create</code> function can be used in exactly the same way as the <code>EyeTracker::create</code> function but the <code>PredictingEyeTracker</code> will only provide output to connected <code>EyePairListener</code> instances when one of the <code>predict</code> functions is called.</p>
<p >An application might define the same type of <code>EyePairListener</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>EyePairListenerImplementation : <span class="keyword">public</span> <a class="code hl_class" href="classSR_1_1EyePairListener.html">SR::EyePairListener</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Ensures EyePairStream is cleaned up when Listener object is out of scope</span></div>
<div class="line">    <a class="code hl_class" href="classSR_1_1InputStream.html">SR::InputStream&lt;SR::EyePairStream&gt;</a> stream;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The accept function can process the eye position data as soon as it becomes available</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> accept(<span class="keyword">const</span> <a class="code hl_struct" href="structSR__eyePair.html">SR_eyePair</a>&amp; frame)<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Use EyeTracker data</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Create EyeTracker</span></div>
<div class="line">    <a class="code hl_class" href="classSR_1_1SRContext.html">SR::SRContext</a> context;</div>
</div><!-- fragment --><p >The <code>EyeTracker::create</code> call is replaced with <code>PredictingEyeTracker::create</code>.</p>
<div class="fragment"><div class="line"><a class="code hl_class" href="classSR_1_1PredictingEyeTracker.html">SR::PredictingEyeTracker</a>* eyeTracker = <a class="code hl_function" href="classSR_1_1PredictingEyeTracker.html#aba5681ebe551e7031f9bcc183cda3c92">SR::PredictingEyeTracker::create</a>(context);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Construct listener</span></div>
<div class="line">EyePairListenerImplementation listener;</div>
<div class="line">listener.stream.set(eyeTracker-&gt;<a class="code hl_function" href="classSR_1_1PredictingEyeTracker.html#a3a1104297d5a98cf7c5377823ff78c1d">openEyePairStream</a>(&amp;listener));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Start tracking</span></div>
<div class="line">context.<a class="code hl_function" href="classSR_1_1SRContext.html#a6e889901b983ced27c24732fcae177c1">initialize</a>();</div>
<div class="ttc" id="aclassSR_1_1PredictingEyeTracker_html"><div class="ttname"><a href="classSR_1_1PredictingEyeTracker.html">SR::PredictingEyeTracker</a></div><div class="ttdoc">Sense class which provides predictive eye tracking functionality.</div><div class="ttdef"><b>Definition:</b> predictingeyetracker.h:28</div></div>
<div class="ttc" id="aclassSR_1_1PredictingEyeTracker_html_a3a1104297d5a98cf7c5377823ff78c1d"><div class="ttname"><a href="classSR_1_1PredictingEyeTracker.html#a3a1104297d5a98cf7c5377823ff78c1d">SR::PredictingEyeTracker::openEyePairStream</a></div><div class="ttdeci">virtual std::shared_ptr&lt; EyePairStream &gt; openEyePairStream(EyePairListener *listener) override</div><div class="ttdoc">Creates a EyePairStream for listener to be connected to.</div></div>
<div class="ttc" id="aclassSR_1_1PredictingEyeTracker_html_aba5681ebe551e7031f9bcc183cda3c92"><div class="ttname"><a href="classSR_1_1PredictingEyeTracker.html#aba5681ebe551e7031f9bcc183cda3c92">SR::PredictingEyeTracker::create</a></div><div class="ttdeci">static PredictingEyeTracker * create(SRContext &amp;context)</div><div class="ttdoc">Returns a class of PredictingEyeTracker.</div></div>
</div><!-- fragment --><p >To trigger the listener to receive new data the <code>predict</code> function can be called as follows.</p>
<div class="fragment"><div class="line">    <span class="comment">// Program loop</span></div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        eyeTracker-&gt;<a class="code hl_function" href="classSR_1_1PredictingEyeTracker.html#a8cfdb3a9151dcc6ef00aba8567a903e2">predict</a>(80);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Sleep in between predictions to simulate actual work being done in between frames</span></div>
<div class="line">        <span class="keyword">using namespace </span>std::chrono_literals;</div>
<div class="line">        std::this_thread::sleep_for(16ms);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclassSR_1_1PredictingEyeTracker_html_a8cfdb3a9151dcc6ef00aba8567a903e2"><div class="ttname"><a href="classSR_1_1PredictingEyeTracker.html#a8cfdb3a9151dcc6ef00aba8567a903e2">SR::PredictingEyeTracker::predict</a></div><div class="ttdeci">void predict(uint64_t latency, SR_eyePair &amp;output)</div><div class="ttdoc">Predict for a certain latency, output an SR_eyePair and trigger stream output.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md49"></a>
Synchronous use of PredictingEyeTracker</h2>
<p >In the above example, the work associated with filtering will be executed asynchronously. This can be useful to increase parallelization but might be difficult to control.</p>
<p >Since the <code>PredictingEyeTracker</code> is also an <code>EyePairListener</code> implementation. This still maintains a similar structure in your application. The developer does not have to define their own listener implementation in this case.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Create EyeTracker</span></div>
<div class="line">    <a class="code hl_class" href="classSR_1_1SRContext.html">SR::SRContext</a> context;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classSR_1_1PredictingEyeTracker.html">SR::PredictingEyeTracker</a>* eyeTracker = <a class="code hl_function" href="classSR_1_1PredictingEyeTracker.html#aba5681ebe551e7031f9bcc183cda3c92">SR::PredictingEyeTracker::create</a>(context);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Start tracking</span></div>
<div class="line">    context.<a class="code hl_function" href="classSR_1_1SRContext.html#a6e889901b983ced27c24732fcae177c1">initialize</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Program loop</span></div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        <a class="code hl_struct" href="structSR__eyePair.html">SR_eyePair</a> eyePair;</div>
<div class="line">        eyeTracker-&gt;<a class="code hl_function" href="classSR_1_1PredictingEyeTracker.html#a8cfdb3a9151dcc6ef00aba8567a903e2">predict</a>(80, eyePair);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Use EyeTracker data</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Sleep in between predictions to simulate actual work being done in between frames</span></div>
<div class="line">        <span class="keyword">using namespace </span>std::chrono_literals;</div>
<div class="line">        std::this_thread::sleep_for(16ms);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
